#!/usr/bin/env node

const fs = require('fs')
const path = require('path')
const process = require('process')

const movedFiles = []

if(process.argv.length < 3) {
  badUsage()
}

switch (process.argv[2]) {
  case 'list':
    listDirectory(process.argv[3])
    break
  case 'move':
    moveFiles(process.argv[3], process.argv[4], process.argv[5])
    break
  default:
    badUsage()
}

function listDirectory (directory = '.') {
  const filenames = []
  walkSync(directory, function (basedir, filename, stat) {
    if (!stat.isDirectory()) {
      filenames.push(filename)
    }
  })

  filenames.sort()
  for (let fileName of filenames) {
    console.log(fileName)
  }
}

function moveFiles (moveList, directory = '.', baseDestinationDir) {
  if (!moveList) {
    badUsage()
  }

  const { fileList, withoutExtList } = makeFileList(directory, moveList)

  const moveListLines = fs.readFileSync(moveList).toString().split('\n')
  let toMove = 0

  function moveFromAllDirectories(filename, newPath) {
    for (let sourceDir of fileList[filename]) {
      let oldPath = path.join(sourceDir, filename)
      toMove++
      moveFile(oldPath, newPath, function (err) {
        if (err) {
          console.log(`ERR: Error moving from '${oldPath} to ${newPath}`, err.message)
        }
        toMove--
      })
    }
  }

  for (let newPath of moveListLines) {
    if (newPath) {
      if(baseDestinationDir) {
        newPath = path.join(baseDestinationDir, newPath)
      }

      const dirname = path.resolve(directory, path.dirname(newPath))
      mkdirRecurs(dirname)

      let managed = false

      const filename = path.basename(newPath)
      if (fileList[filename]) {
        moveFromAllDirectories(filename, newPath)
        managed = true
      }

      if (withoutExtList[filename]) {
        for (let withExtension of withoutExtList[filename]) {
          if (withExtension !== filename) {
            if (fileList[withExtension]) {
              const ext = path.extname(withExtension)
              moveFromAllDirectories(withExtension, newPath + ext)
              managed = true
            }
            else {
              console.log(`ERR: File '${withExtension}' does not exit`)
            }
          }
        }
      }

      if (!managed) {
        console.log(`ERR: File '${filename}' does not exit`)
      }
    }
  }

  function cleanDirectory () {
    if (toMove === 0) {
      cleanEmptyFoldersRecursively(directory)
    } else {
      setTimeout(cleanDirectory, 500)
    }
  }

  setTimeout(cleanDirectory, 500)
}

function badUsage () {
  console.error(`Invalid usage.
  mass-file-mover list <directory|.>
  mass-file-mover move <moveList> <directory|.> <base destination dir>`)
  process.exit(-1)
}

function makeFileList(directory, moveList) {
  const fileList = {}
  const withoutExtList = {}
  const moveListFilename = path.basename(moveList)

  walkSync(directory, function (basedir, filename, stat) {
    if (!stat.isDirectory()) {
      if (moveListFilename === filename && path.join(basedir, filename) === moveList) {
        return
      }

      if (fileList[filename]) {
        console.log(`WARN: File '${filename} is duplicated`)
        fileList[filename].push(basedir)
      }
      else {
        fileList[filename] = [basedir]
      }

      const withoutExt = path.basename(filename, path.extname(filename))
      if (withoutExtList[withoutExt]) {
        if (!withoutExtList[withoutExt].includes(filename)) {
          withoutExtList[withoutExt].push(filename)
        }
      } else {
        withoutExtList[withoutExt] = [filename]
      }
    }
  })

  return { fileList, withoutExtList }
}

function mkdirRecurs (dirname, mode = '0777') {
  if (!fs.existsSync(dirname)) {
    dirname.split('/').forEach((dir, index, splits) => {
      let parent = splits.slice(0, index).join('/')
      if (!parent) {
        parent = '/'
      }
      const dirPath = path.join(parent, dir)
      if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, mode)
      }
    })
  }
}

function moveFile(oldPath, newPath, callback) {
  if (oldPath === newPath || movedFiles.includes(oldPath)) {
    callback()
  } else {
    movedFiles.push(oldPath)
    newPath = findNonExistingFilename(newPath)
    fs.rename(oldPath, newPath, function (err) {
      if (err) {
        if (err.code === 'EXDEV') {
          copyFile()
        } else {
          callback(err)
        }
      } else {
        console.log(`Moved '${oldPath}' --> '${newPath}'`)
        callback()
      }
    })
  }

  function copyFile() {
    const readStream = fs.createReadStream(oldPath)
    const writeStream = fs.createWriteStream(newPath)

    readStream.on('error', callback)
    writeStream.on('error', callback)

    readStream.on('close', function () {
      console.log(`Moved (using copy) '${oldPath}' --> '${newPath}'`)
      fs.unlink(oldPath, callback)
    })

    readStream.pipe(writeStream)
  }
}

function findNonExistingFilename(fullPath) {
  let count = 0
  let result = fullPath
  while (true) {
    if (!fs.existsSync(result)) {
      return result
    }

    let extname = path.extname(fullPath)
    const basename = path.basename(fullPath, extname)

    count++
    result = `${basename}-${count}${extname}`
  }
}

/**
 * Synchronously list `dir` and all its descendents,
 * calling `iterator` for each entry.
 *
 * @param {String} dir Path to the base directory of the listing.
 * @param {Function} iterator Function that will be called
 * for each entry in the listing, passing 4 arguments:
 *   * `basedir`: Base directory of the entry (relative to `dir`).
 *   * `file`: Name of the file
 *   * `stat`: Result of calling `fs.stat`
 *
 */
function walkSync (dir, iterator) {
  const dirs = [dir]

  while (dirs.length) {
    const directory = dirs.shift()

    let files
    try {
      files = fs.readdirSync(directory)
    } catch (error) {
      console.error(`ERR: Cannot read directory ${directory}`, error.message)
      continue
    }

    files.forEach(function (file) {
      const f = path.join(directory, file)
      let stat
      try {
        stat = fs.statSync(f)
        if (stat && stat.isDirectory()) {
          dirs.push(f)
        }
      } catch (error) {
        console.error(`ERR: Cannot stat ${f}`, error.message)
      }

      if (stat) {
        iterator(directory, file, stat)
      }
    })
  }
}

function cleanEmptyFoldersRecursively (folder) {
  const isDir = fs.statSync(folder).isDirectory()
  if (!isDir) {
    return
  }
  let files = fs.readdirSync(folder)
  if (files.length > 0) {
    files.forEach(function(file) {
      const fullPath = path.join(folder, file)
      cleanEmptyFoldersRecursively(fullPath)
    })

    // re-evaluate files after deleting subfolder
    // we may have parent folder empty now
    files = fs.readdirSync(folder)
  }

  if (files.length == 0) {
    console.log(`Removing '${folder}'`)
    fs.rmdirSync(folder)
  }
}
