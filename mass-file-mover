#!/usr/bin/env node

const fs = require('fs')
const path = require('path')
const process = require('process')

if(process.argv.length < 3) {
  badUsage()
}

switch (process.argv[2]) {
  case 'list':
    listDirectory(process.argv[3])
    break
  case 'move':
    moveFiles(process.argv[3], process.argv[4])
    break
  default:
    badUsage()
}

function listDirectory (directory = '.') {
  const filenames = []
  walkSync(directory, function (basedir, filename, stat) {
    if (!stat.isDirectory()) {
      filenames.push(filename)
    }
  })

  filenames.sort()
  for (let fileName of filenames) {
    console.log(fileName)
  }
}

function moveFiles (moveList, directory = '.') {
  if (!moveList) {
    badUsage()
  }

  const fileList = makeFileList(directory, moveList)

  const moveListLines = fs.readFileSync(moveList).toString().split('\n')
  moveListLines.forEach(function (newPath) {
    if(newPath) {
      const dirname = path.dirname(newPath)
      mkdirRecurs(dirname)

      const filename = path.basename(newPath)
      if (fileList[filename]) {
        for (let sourceDir of fileList[filename]) {
          let oldPath = path.join(sourceDir, filename)
          moveFile(oldPath, newPath, function (err) {
            if (err) {
              console.log(`ERR: Error moving from '${oldPath} to ${newPath}`, err.message)
            }
          })
        }
      }
      else {
        console.log(`ERR: File '${filename}' does not exit`)
      }
    }
  })

  cleanEmptyFoldersRecursively(directory)
}

function badUsage () {
  console.error(`Invalid usage.
  mass-file-mover list <directory|.>
  mass-file-mover move <moveList> <directory|.>`)
  process.exit(-1)
}

function makeFileList(directory, moveList) {
  const fileList = {}
  const moveListFilename = path.basename(moveList)

  walkSync(directory, function (basedir, filename, stat) {
    if (!stat.isDirectory()) {
      if (moveListFilename === filename && path.join(basedir, filename) === moveList) {
        return
      }

      if (fileList[filename]) {
        console.log(`WARN: File '${filename} is duplicated`)
        fileList[filename].push(basedir)
      }
      else {
        fileList[filename] = [basedir]
      }
    }
  })

  return fileList
}

function mkdirRecurs (dirname, mode = '0777') {
  if (!fs.existsSync(dirname)) {
    dirname.split('/').forEach((dir, index, splits) => {
      const parent = splits.slice(0, index).join('/')
      const dirPath = path.resolve(parent, dir)
      if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, mode)
      }
    })
  }
}

function moveFile(oldPath, newPath, callback) {
  if (oldPath !== newPath) {
    console.log(`Move '${oldPath}' --> '${newPath}'`)
    fs.rename(oldPath, newPath, function (err) {
      if (err) {
        if (err.code === 'EXDEV') {
          copyFile()
        } else {
          callback(err)
        }
        return
      }
      callback()
    })
  }

  function copyFile() {
    const readStream = fs.createReadStream(oldPath)
    const writeStream = fs.createWriteStream(newPath)

    readStream.on('error', callback)
    writeStream.on('error', callback)

    readStream.on('close', function () {
      fs.unlink(oldPath, callback)
    })

    readStream.pipe(writeStream)
  }
}

/**
 * Synchronously list `dir` and all its descendents,
 * calling `iterator` for each entry.
 *
 * @param {String} dir Path to the base directory of the listing.
 * @param {Function} iterator Function that will be called
 * for each entry in the listing, passing 4 arguments:
 *   * `basedir`: Base directory of the entry (relative to `dir`).
 *   * `file`: Name of the file
 *   * `stat`: Result of calling `fs.stat`
 *
 */
function walkSync (dir, iterator) {
  const dirs = [dir]

  while (dirs.length) {
    const directory = dirs.shift()

    let files
    try {
      files = fs.readdirSync(directory)
    } catch (error) {
      console.error(`ERR: Cannot read directory ${directory}`, error.message)
      continue
    }

    files.forEach(function (file) {
      const f = path.join(directory, file)
      let stat
      try {
        stat = fs.statSync(f)
        if (stat && stat.isDirectory()) {
          dirs.push(f)
        }
      } catch (error) {
        console.error(`ERR: Cannot stat ${f}`, error.message)
      }

      if (stat) {
        iterator(directory, file, stat)
      }
    })
  }
}

function cleanEmptyFoldersRecursively (folder) {
  const isDir = fs.statSync(folder).isDirectory()
  if (!isDir) {
    return
  }
  let files = fs.readdirSync(folder)
  if (files.length > 0) {
    files.forEach(function(file) {
      const fullPath = path.join(folder, file)
      cleanEmptyFoldersRecursively(fullPath)
    })

    // re-evaluate files after deleting subfolder
    // we may have parent folder empty now
    files = fs.readdirSync(folder)
  }

  if (files.length == 0) {
    console.log(`Removing '${folder}'`)
    fs.rmdirSync(folder)
  }
}
